<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: design-patterns, | Bob Lauer]]></title>
  <link href="http://boblauer.github.io/blog/categories/design-patterns/atom.xml" rel="self"/>
  <link href="http://boblauer.github.io/"/>
  <updated>2013-07-16T16:24:32-05:00</updated>
  <id>http://boblauer.github.io/</id>
  <author>
    <name><![CDATA[Bob Lauer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Updating Wikipedia's Decorator Pattern JavaScript Example]]></title>
    <link href="http://boblauer.github.io/blog/2013/07/15/updating-wikipedias-decorator-pattern-javascript-example/"/>
    <updated>2013-07-15T22:16:00-05:00</updated>
    <id>http://boblauer.github.io/blog/2013/07/15/updating-wikipedias-decorator-pattern-javascript-example</id>
    <content type="html"><![CDATA[<p>I have recently been working through <a target="_blank" href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">Addy Osmani's open-source book 'Learning JavaScript Design Patterns'</a>.  This led me to look up the Decorater Pattern, which then led me to an example of the Decorator Patterns on Wikipedia that was written in JavaScript (the example has since been removed from the Wikipedia page).  After looking at the code for a bit, I noticed that it had at least two flaws in it.  The code that was there at the time was:</p>


<!-- more -->


<p>```javascript
// Class to be decorated
function Coffee() {</p>

<pre><code>this.cost = function() {
    return 1;
};
</code></pre>

<p>}</p>

<p>// Decorator A
function Milk(coffee) {</p>

<pre><code>this.cost = function() {
    return coffee.cost() + 0.5;
};
</code></pre>

<p>}</p>

<p>// Decorator B
function Whip(coffee) {</p>

<pre><code>this.cost = function() {
    return coffee.cost() + 0.7;
};
</code></pre>

<p>}</p>

<p>// Decorator C
function Sprinkles(coffee) {</p>

<pre><code>this.cost = function() {
    return coffee.cost() + 0.2;
};
</code></pre>

<p>}</p>

<p>// Here&rsquo;s one way of using it
var coffee = new Milk(new Whip(new Sprinkles(new Coffee())));
alert( coffee.cost() );</p>

<p>// Here&rsquo;s another
var coffee = new Coffee();
coffee = new Sprinkles(coffee);
coffee = new Whip(coffee);
coffee = new Milk(coffee);
alert(coffee.cost());
```</p>

<p>There are at least two problems that I can see with this code.  The first problem is that the cost function on Coffee is defined within the constructor, rather than being a property on Coffee's prototype object.  This means that every time ```new Coffee()``` is called, a new instance of the cost function will be created, rather than all Coffee instances sharing the same function.</p>


<p>The much bigger second problem is let's say we were to add the following code:</p>


<p><code>javascript
Coffee.prototype.getTemperature = function() {
  return "155";
};
</code></p>

<p>we can now do something like this:</p>


<p><code>javascript
var coffee = new Coffee();
coffee.getTemperature();
</code></p>

<p>However, once we decorate our coffee object (e.g. <code>coffee = new Sprinkles(coffee)</code>), we no longer have an object of type Coffee anymore; we have an object of type Sprinkes instead.  This means that all of our custom methods that were defined on Coffee.prototype are no longer available to us.</p>


<p>To fix this, we need to make sure that our Decorators always return the same Coffee object that was passed in to the constructor function.  Here's what that code looks like:</p>


<p>```javascript
// Class to be decorated
function Coffee() {</p>

<p>}</p>

<p>Coffee.prototype.cost = function() {
  return 1;
};</p>

<p>// Decorator A
function Milk(coffee) {
  var currentCost = coffee.cost();
  coffee.cost = function() {</p>

<pre><code>return currentCost + 0.5;
</code></pre>

<p>  };</p>

<p>  return coffee;
}</p>

<p>// Decorator B
function Whip(coffee) {
  var currentCost = coffee.cost();
  coffee.cost = function() {</p>

<pre><code>return currentCost + 0.7;
</code></pre>

<p>  };</p>

<p>  return coffee;
}</p>

<p>// Decorator C
function Sprinkles(coffee) {
  var currentCost = coffee.cost();
  coffee.cost = function() {</p>

<pre><code>return currentCost + 0.2;
</code></pre>

<p>  };</p>

<p>  return coffee;
}
```</p>

<p>The code is fairly straight forward.  Each Decorator simply takes an instance of Coffee in as a constructor parameter, augments its cost function, and returns it.  The interesting part is that we can use these Decorators as both normal functions (<code>coffee = Milk(coffee)</code>) and as constructors (<code>coffee = new Milk(coffee)</code>) and achieve the same results.  This is because our constructor functions explicitly return the <code>coffee</code> object, rather than implicitly returning the <code>this</code> object.</p>


<p>This might violate the law of least surprises, since typically when you're using the <code>new</code> keyword in JavaScript you would expect to get a new object back.  However, if we're aware that we're using these constructors to decorate the Coffee object, it should be fairly obvious that we should be getting back the same object that we passed in.</p>


<p>That said, if you really don't like using a constructor to augment an object, you could always make the Decorators normal functions.  Something like this:</p>


<p>```javascript
// Class to be decorated
function Coffee() {</p>

<p>}</p>

<p>Coffee.prototype.cost = function() {
  return 1;
};</p>

<p>Coffee.Decorators = {
  milk: function(coffee) {</p>

<pre><code>var currentCost = coffee.cost();
coffee.cost = function() {
  return currentCost + 0.5;
};

return coffee;
</code></pre>

<p>  },
  whip: function(coffee) {</p>

<pre><code>var currentCost = coffee.cost();
coffee.cost = function() {
  return currentCost + 0.7;
};

return coffee;
</code></pre>

<p>  },
  sprinkles: function(coffee) {</p>

<pre><code>var currentCost = coffee.cost();
coffee.cost = function() {
  return currentCost + 0.2;
};

return coffee;
</code></pre>

<p>  }
};</p>

<p>var coffee = new Coffee();
coffee = Coffee.Decorators.sprinkles(coffee);
coffee = Coffee.Decorators.whip(coffee);
coffee = Coffee.Decorators.milk(coffee);
alert(coffee.cost());
```</p>

<p>The Decorator Pattern is a great design pattern, and is definitely a handy tool to have in your arsenal.  If you're interested in learning more about design patterns, and specifically how they can be written in JavaScript, I suggest you take a look at <a target="_blank" href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">Addy Osmani's open-source book 'Learning JavaScript Design Patterns'</a>.</p>

]]></content>
  </entry>
  
</feed>
